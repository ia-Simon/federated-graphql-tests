package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.75

import (
	"context"
	"errors"
	"log/slog"
	"product-subgraph/graph/model"

	"github.com/google/uuid"
)

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input model.NewProduct) (*model.Product, error) {
	if input.Description == nil {
		defaultDesc := "-"
		input.Description = &defaultDesc
	}

	newProduct := &model.Product{
		Sku:         uuid.NewString(),
		Name:        input.Name,
		Price:       input.Price,
		Description: *input.Description,
	}

	_, err := r.Datastore.ExecContext(ctx, `
		INSERT INTO "product" ("sku", "name", "price", "description")
		VALUES ($1, $2, $3, $4);`,
		newProduct.Sku, newProduct.Name, newProduct.Price, newProduct.Description,
	)
	if err != nil {
		slog.Error("failed to persist new product", slog.Any("error", err))
		return nil, errors.New("failed to persist new product")
	}

	return newProduct, nil
}

// Reviews is the resolver for the reviews field.
func (r *productResolver) Reviews(ctx context.Context, obj *model.Product) ([]*model.Review, error) {
	rows, err := r.Datastore.QueryContext(ctx, `
		SELECT r.id FROM "review" r
		WHERE r.product_sku = $1;`,
		obj.Sku,
	)
	if err != nil {
		slog.Error("failed to retrieve product reviews", slog.Any("error", err), slog.String("productSku", obj.Sku))
		return nil, errors.New("failed to retrieve product reviews")
	}

	var reviews []*model.Review
	for rows.Next() {
		review := new(model.Review)
		err := rows.Scan(&review.ID)
		if err != nil {
			slog.Warn("failed to scan row from result", slog.Any("error", err))
			continue
		}
		reviews = append(reviews, review)
	}
	if err = rows.Err(); err != nil {
		slog.Warn("rows iteration finished with error", slog.Any("error", err))
	}

	return reviews, nil
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context) ([]*model.Product, error) {
	rows, err := r.Datastore.QueryContext(ctx, `
		SELECT p.sku, p.name, p.price, p.description
		FROM "product" p;`,
	)
	if err != nil {
		slog.Error("failed to retrieve products", slog.Any("error", err))
		return nil, errors.New("failed to retrieve products")
	}

	var products []*model.Product
	for rows.Next() {
		product := new(model.Product)
		err := rows.Scan(&product.Sku, &product.Name, &product.Price, &product.Description)
		if err != nil {
			slog.Warn("failed to scan row from result", slog.Any("error", err))
			continue
		}
		products = append(products, product)
	}
	if err = rows.Err(); err != nil {
		slog.Warn("rows iteration finished with error", slog.Any("error", err))
	}

	return products, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Product returns ProductResolver implementation.
func (r *Resolver) Product() ProductResolver { return &productResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type productResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
